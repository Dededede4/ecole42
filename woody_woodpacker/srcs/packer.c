#include "woody.h"

unsigned char virus[VIRUS_SIZE] = {
	0x55, 0x54, 0x48, 0x89, 0xe5, 0x53, 0x50, 0x57, 0x56, 0x54, 0x52, 0x51, 0x6a, 0x0a, 0x6a, 0x2e,
	0x6a, 0x2e, 0x6a, 0x2e, 0x6a, 0x2e, 0x6a, 0x2e, 0x6a, 0x59, 0x6a, 0x44, 0x6a, 0x4f, 0x6a, 0x4f,
	0x6a, 0x57, 0x6a, 0x2e, 0x6a, 0x2e, 0x6a, 0x2e, 0x6a, 0x2e, 0xb8, 0x94, 0x93, 0x92, 0x91, 0xb8,
	0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xe6, 0xba, 0x78, 0x00, 0x00,
	0x00, 0x0f, 0x05, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
	0x58, 0x58, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x48, 0xbb, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x58, 0x48, 0x83, 0xc0, 0x02, 0x48, 0xb9, 0x42, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43,
	0x48, 0x29, 0xd8, 0x48, 0xba, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x48, 0x01, 0xc1,
	0x30, 0x10, 0x48, 0xc1, 0xca, 0x08, 0x48, 0xff, 0xc0, 0x48, 0x39, 0xc8, 0x75, 0xf2, 0x59, 0x5a,
	0x5c, 0x5e, 0x5f, 0x58, 0x5b, 0x5c, 0x5d
};

static Elf64_Shdr	*get_text_segment(Elf64_Ehdr *map)
{
	Elf64_Shdr	*tmp;
	char		*tab;
	int		i;


	if (map->e_shoff > 0) {
		tmp = (Elf64_Shdr * )((void*) map + map->e_shoff);
		tab = (char*)(((void*)map) + (tmp[map->e_shstrndx]).sh_offset);
		for (i = 0; i < map->e_shnum; i++) {
			if (ft_strcmp(".text", tab + tmp->sh_name) == 0)
				return (tmp);
			tmp++;
		}
		
	}
	return NULL;
}

static void		parse_ph64(Elf64_Ehdr *map, unsigned int *maxaddr, int *maxoff, Elf64_Phdr **saved)
{
	Elf64_Phdr	*tmp;
	int		i;

	*maxaddr = 0x0;
	*maxoff = 0x0;
	*saved = NULL;
	if (map->e_phnum > 0) {
		tmp = (Elf64_Phdr *)((void *)map + map->e_phoff);
		for (i = 0; i < map->e_phnum; i++) {
			if (*maxaddr < tmp->p_vaddr + tmp->p_memsz) {
				if ((tmp->p_flags & PF_X) > 0) {
					tmp->p_flags |= PF_W;
					*maxaddr = tmp->p_vaddr + tmp->p_memsz;
					*maxoff = tmp->p_offset + tmp->p_filesz;
					*saved = tmp;
				}
			}
			tmp++;
		}
	}
}


int	packer(Elf64_Ehdr *map, int64_t const size, unsigned char *secret)
{
	unsigned int	maxaddr;
	int		maxoff;
	Elf64_Phdr	*saved;
	Elf64_Shdr	*segment;

	if (check_file_ident(map, size) < 0)
		return -1;

	parse_ph64(map, &maxaddr, &maxoff, &saved);
	if (maxoff > size) {
		dprintf(STDERR_FILENO, "Error: invalid file format\n");
		return -1;	
	}
	if (maxaddr == 0 || (check_cave_len((char *)map + maxoff) < VIRUS_SIZE)) {
		dprintf(STDERR_FILENO, "Error: not enough space to insert payload\n");
		return -1;
	}
	if (NULL == (segment = get_text_segment(map)))
		return -1;

	printf("Secret: %lu\n", *((uint64_t*)secret));
	encrypt_main(((void*)map) + segment->sh_offset, maxoff - segment->sh_offset, secret);
	if(inject_code(map, maxaddr,  maxoff, maxoff - segment->sh_offset, *((uint64_t*)secret)) == -1)
		return -1;

	saved->p_memsz += VIRUS_SIZE;
	saved->p_filesz += VIRUS_SIZE;
        segment->sh_size += VIRUS_SIZE;
	return 0;
}
